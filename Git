}
_git_gitk ()
{
    __gitk_main
}
_git_grep ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp_builtin grep;
            return
        ;;
    esac;
    case "$cword,$prev" in
        $((__git_cmd_idx+1)),* | *,-*)
            __git_complete_symbol && return
        ;;
    esac;
    __git_complete_refs
}
_git_help ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin help;
            return
        ;;
    esac;
    if test -n "${GIT_TESTING_ALL_COMMAND_LIST-}"; then
        __gitcomp "$GIT_TESTING_ALL_COMMAND_LIST $(__git --list-cmds=alias,list-guide) gitk";
    else
        __gitcomp "$(__git --list-cmds=main,nohelpers,alias,list-guide) gitk";
    fi
}
_git_init ()
{
    case "$cur" in
        --shared=*)
            __gitcomp "
                        false true umask group all world everybody
                        " "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp_builtin init;
            return
        ;;
    esac
}
_git_log ()
{
    __git_has_doubledash && return;
    __git_find_repo_path;
    __git_complete_log_opts;
    [ ${#COMPREPLY[@]} -eq 0 ] || return;
    __git_complete_revlist
}
_git_ls_files ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-files;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_ls_remote ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-remote;
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_remotes)"
}
_git_ls_tree ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-tree;
            return
        ;;
    esac;
    __git_complete_file
}
_git_merge ()
{
    __git_complete_strategy && return;
    case "$cur" in
        --*)
            __gitcomp_builtin merge;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_merge_base ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin merge-base;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_mergetool ()
{
    case "$cur" in
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool= --prompt --no-prompt --gui --no-gui";
            return
        ;;
    esac
}
_git_mv ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin mv;
            return
        ;;
    esac;
    if [ $(__git_count_arguments "mv") -gt 0 ]; then
        __git_complete_index_file "--cached --others --directory";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_notes ()
{
    local subcommands='add append copy edit get-ref list merge prune remove show';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    case "$subcommand,$cur" in
        ,--*)
            __gitcomp_builtin notes
        ;;
        ,*)
            case "$prev" in
                --ref)
                    __git_complete_refs
                ;;
                *)
                    __gitcomp "$subcommands --ref"
                ;;
            esac
        ;;
        *,--reuse-message=* | *,--reedit-message=*)
            __git_complete_refs --cur="${cur#*=}"
        ;;
        *,--*)
            __gitcomp_builtin notes_$subcommand
        ;;
        prune,* | get-ref,*)

        ;;
        *)
            case "$prev" in
                -m | -F)

                ;;
                *)
                    __git_complete_refs
                ;;
            esac
        ;;
    esac
}
_git_pull ()
{
    __git_complete_strategy && return;
    case "$cur" in
        --recurse-submodules=*)
            __gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --*)
            __gitcomp_builtin pull;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_push ()
{
    case "$prev" in
        --repo)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
        --recurse-submodules)
            __gitcomp "$__git_push_recurse_submodules";
            return
        ;;
    esac;
    case "$cur" in
        --repo=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --recurse-submodules=*)
            __gitcomp "$__git_push_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --force-with-lease=*)
            __git_complete_force_with_lease "${cur##--force-with-lease=}";
            return
        ;;
        --*)
            __gitcomp_builtin push;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_range_diff ()
{
    case "$cur" in
        --*)
            __gitcomp "
                        --creation-factor= --no-dual-color
                        $__git_diff_common_options
                ";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_rebase ()
{
    __git_find_repo_path;
    if [ -f "$__git_repo_path"/rebase-merge/interactive ]; then
        __gitcomp "$__git_rebase_interactive_inprogress_options";
        return;
    else
        if [ -d "$__git_repo_path"/rebase-apply ] || [ -d "$__git_repo_path"/rebase-merge ]; then
            __gitcomp "$__git_rebase_inprogress_options";
            return;
        fi;
    fi;
    __git_complete_strategy && return;
    case "$cur" in
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --onto=*)
            __git_complete_refs --cur="${cur##--onto=}";
            return
        ;;
        --*)
            __gitcomp_builtin rebase "" "$__git_rebase_interactive_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_reflog ()
{
    local subcommands="show delete expire";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        __git_complete_refs;
    fi
}
_git_remote ()
{
    local subcommands="
                add rename remove set-head set-branches
                get-url set-url show prune update
                ";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in
            --*)
                __gitcomp_builtin remote
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        add,--*)
            __gitcomp_builtin remote_add
        ;;
        add,*)

        ;;
        set-head,--*)
            __gitcomp_builtin remote_set-head
        ;;
        set-branches,--*)
            __gitcomp_builtin remote_set-branches
        ;;
        set-head,* | set-branches,*)
            __git_complete_remote_or_refspec
        ;;
        update,--*)
            __gitcomp_builtin remote_update
        ;;
        update,*)
            __gitcomp "$(__git_remotes) $(__git_get_config_variables "remotes")"
        ;;
        set-url,--*)
            __gitcomp_builtin remote_set-url
        ;;
        get-url,--*)
            __gitcomp_builtin remote_get-url
        ;;
        prune,--*)
            __gitcomp_builtin remote_prune
        ;;
        *)
            __gitcomp_nl "$(__git_remotes)"
        ;;
    esac
}
_git_replace ()
{
    case "$cur" in
        --format=*)
            __gitcomp "short medium long" "" "${cur##--format=}";
            return
        ;;
        --*)
            __gitcomp_builtin replace;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rerere ()
{
    local subcommands="clear forget diff remaining status gc";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if test -z "$subcommand"; then
        __gitcomp "$subcommands";
        return;
    fi
}
_git_reset ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp_builtin reset;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_restore ()
{
    case "$prev" in
        -s)
            __git_complete_refs;
            return
        ;;
    esac;
    case "$cur" in
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --source=*)
            __git_complete_refs --cur="${cur##--source=}"
        ;;
        --*)
            __gitcomp_builtin restore
        ;;
        *)
            if __git_pseudoref_exists HEAD; then
                __git_complete_index_file "--modified";
            fi
        ;;
    esac
}
_git_revert ()
{
    if __git_pseudoref_exists REVERT_HEAD; then
        __gitcomp "$__git_revert_inprogress_options";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in
        --*)
            __gitcomp_builtin revert "" "$__git_revert_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rm ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin rm;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_send_email ()
{
    case "$prev" in
        --to | --cc | --bcc | --from)
            __gitcomp "$(__git send-email --dump-aliases)";
            return
        ;;
    esac;
    case "$cur" in
        --confirm=*)
            __gitcomp "
                        $__git_send_email_confirm_options
                        " "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
                        $__git_send_email_suppresscc_options
                        " "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --thread=*)
            __gitcomp "
                        deep shallow
                        " "" "${cur##--thread=}";
            return
        ;;
        --to=* | --cc=* | --bcc=* | --from=*)
            __gitcomp "$(__git send-email --dump-aliases)" "" "${cur#--*=}";
            return
        ;;
        --*)
            __gitcomp_builtin send-email "$__git_format_patch_extra_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_shortlog ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp "
                        $__git_log_common_options
                        $__git_log_shortlog_options
                        --numbered --summary --email
                        ";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_show ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
                        " "" "${cur#*=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --color-moved=*)
            __gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}";
            return
        ;;
        --color-moved-ws=*)
            __gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}";
            return
        ;;
        --ws-error-highlight=*)
            __gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}";
            return
        ;;
        --diff-merges=*)
            __gitcomp "$__git_diff_merges_opts" "" "${cur##--diff-merges=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --no-abbrev-commit
                        --oneline --show-signature
                        --expand-tabs --expand-tabs= --no-expand-tabs
                        $__git_log_show_options
                        $__git_diff_common_options
                        ";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_show_branch ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin show-branch;
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_sparse_checkout ()
{
    local subcommands="list init set disable add reapply";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    local using_cone=true;
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand,$cur" in
        *,--*)
            __gitcomp_builtin sparse-checkout_$subcommand "" "--"
        ;;
        set,* | add,*)
            if [[ "$(__git config core.sparseCheckout)" == "true" && "$(__git config core.sparseCheckoutCone)" == "false" && -z "$(__git_find_on_cmdline --cone)" ]]; then
                using_cone=false;
            fi;
            if [[ -n "$(__git_find_on_cmdline --no-cone)" ]]; then
                using_cone=false;
            fi;
            if [[ "$using_cone" == "true" ]]; then
                __gitcomp_directories;
            else
                __gitcomp_slash_leading_paths;
            fi
        ;;
    esac
}
_git_stage ()
{
    _git_add
}
_git_stash ()
{
    local subcommands='push list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands save")";
    if [ -z "$subcommand" ]; then
        case "$((cword - __git_cmd_idx)),$cur" in
            *,--*)
                __gitcomp_builtin stash_push
            ;;
            1,sa*)
                __gitcomp "save"
            ;;
            1,*)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        list,--*)
            __gitcomp_builtin stash_list "$__git_log_common_options $__git_diff_common_options"
        ;;
        show,--*)
            __gitcomp_builtin stash_show "$__git_diff_common_options"
        ;;
        *,--*)
            __gitcomp_builtin "stash_$subcommand"
        ;;
        branch,*)
            if [ $cword -eq $((__git_cmd_idx+2)) ]; then
                __git_complete_refs;
            else
                __gitcomp_nl "$(__git stash list | sed -n -e 's/:.*//p')";
            fi
        ;;
        show,* | apply,* | drop,* | pop,*)
            __gitcomp_nl "$(__git stash list | sed -n -e 's/:.*//p')"
        ;;
    esac
}
_git_status ()
{
    local complete_opt;
    local untracked_state;
    case "$cur" in
        --ignore-submodules=*)
            __gitcomp "none untracked dirty all" "" "${cur##--ignore-submodules=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}";
            return
        ;;
        --column=*)
            __gitcomp "
                        always never auto column row plain dense nodense
                        " "" "${cur##--column=}";
            return
        ;;
        --*)
            __gitcomp_builtin status;
            return
        ;;
    esac;
    untracked_state="$(__git_get_option_value "-u" "--untracked-files=" "$__git_untracked_file_modes" "status.showUntrackedFiles")";
    case "$untracked_state" in
        no)
            complete_opt=
        ;;
        all | normal | *)
            complete_opt="--cached --directory --no-empty-directory --others";
            if [ -n "$(__git_find_on_cmdline "--ignored")" ]; then
                complete_opt="$complete_opt --ignored --exclude=*";
            fi
        ;;
    esac;
    __git_complete_index_file "$complete_opt"
}
_git_submodule ()
{
    __git_has_doubledash && return;
    local subcommands="add status init deinit update set-branch set-url summary foreach sync absorbgitdirs";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in
            --*)
                __gitcomp "--quiet"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        add,--*)
            __gitcomp "--branch --force --name --reference --depth"
        ;;
        status,--*)
            __gitcomp "--cached --recursive"
        ;;
        deinit,--*)
            __gitcomp "--force --all"
        ;;
        update,--*)
            __gitcomp "
                        --init --remote --no-fetch
                        --recommend-shallow --no-recommend-shallow
                        --force --rebase --merge --reference --depth --recursive --jobs
                "
        ;;
        set-branch,--*)
            __gitcomp "--default --branch"
        ;;
        summary,--*)
            __gitcomp "--cached --files --summary-limit"
        ;;
        foreach,--* | sync,--*)
            __gitcomp "--recursive"
        ;;
        *)

        ;;
    esac
}
_git_svn ()
{
    local subcommands="
                init fetch clone rebase dcommit log find-rev
                set-tree commit-diff info create-ignore propget
                proplist show-ignore show-externals branch tag blame
                migrate mkdirs reset gc
                ";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
                        --follow-parent --authors-file= --repack=
                        --no-metadata --use-svm-props --use-svnsync-props
                        --log-window-size= --no-checkout --quiet
                        --repack-flags --use-log-author --localtime
                        --add-author-from
                        --recursive
                        --ignore-paths= --include-paths= $remote_opts
                        ";
        local init_opts="
                        --template= --shared= --trunk= --tags=
                        --branches= --stdlayout --minimize-url
                        --no-metadata --use-svm-props --use-svnsync-props
                        --rewrite-root= --prefix= $remote_opts
                        ";
        local cmt_opts="
                        --edit --rmdir --find-copies-harder --copy-similarity=
                        ";
        case "$subcommand,$cur" in
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
                                --merge --strategy= --verbose --dry-run
                                --fetch-all --no-rebase --commit-url
                                --revision --interactive $cmt_opts $fc_opts
                                "
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
                                --limit= --revision= --verbose --incremental
                                --oneline --show-commit --non-recursive
                                --authors-file= --color
                                "
            ;;
            rebase,--*)
                __gitcomp "
                                --merge --verbose --strategy= --local
                                --fetch-all --dry-run $fc_opts
                                "
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
                                --config-dir= --ignore-paths= --minimize
                                --no-auth-cache --username=
                                "
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)

            ;;
        esac;
    fi
}
_git_switch ()
{
    local dwim_opt="$(__git_checkout_default_dwim_mode)";
    case "$prev" in
        -c | -C | --orphan)
            __git_complete_refs $dwim_opt --mode="heads";
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp_builtin switch
        ;;
        *)
            if [ -n "$(__git_find_on_cmdline "--orphan")" ]; then
                return;
            fi;
            if [ -n "$(__git_find_on_cmdline "-c -C -d --detach")" ]; then
                __git_complete_refs --mode="refs";
            else
                if [ -n "$(__git_find_on_cmdline "-t --track")" ]; then
                    __git_complete_refs --mode="remote-heads";
                else
                    __git_complete_refs $dwim_opt --mode="heads";
                fi;
            fi
        ;;
    esac
}
_git_tag ()
{
    local i c="$__git_cmd_idx" f=0;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in
            -d | --delete | -v | --verify)
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        ((c++));
    done;
    case "$prev" in
        -m | -F)

        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
            fi
        ;;
        *)
            __git_complete_refs
        ;;
    esac;
    case "$cur" in
        --*)
            __gitcomp_builtin tag
        ;;
    esac
}
_git_whatchanged ()
{
    _git_log
}
_git_worktree ()
{
    local subcommands="add list lock move prune remove unlock";
    local subcommand subcommand_idx;
    subcommand="$(__git_find_on_cmdline --show-idx "$subcommands")";
    subcommand_idx="${subcommand% *}";
    subcommand="${subcommand#* }";
    case "$subcommand,$cur" in
        ,*)
            __gitcomp "$subcommands"
        ;;
        *,--*)
            __gitcomp_builtin worktree_$subcommand
        ;;
        add,*)
            case "$prev" in
                -b | -B)
                    __git_complete_refs
                ;;
                -*)

                ;;
                *)
                    if [ $cword -eq $((subcommand_idx+1)) ]; then
                        :;
                    else
                        case "${words[cword-2]}" in
                            -b | -B)

                            ;;
                            *)
                                __git_complete_refs
                            ;;
                        esac;
                    fi
                ;;
            esac
        ;;
        lock,* | remove,* | unlock,*)
            __git_complete_worktree_paths
        ;;
        move,*)
            if [ $cword -eq $((subcommand_idx+1)) ]; then
                __git_complete_worktree_paths;
            else
                :;
            fi
        ;;
    esac
}
profile_d ()
{
    local file=;
    for file in $(export LC_COLLATE=C; echo /etc/profile.d/*.$1);
    do
        [ -e "${file}" ] && . "${file}";
    done;
    if [ -n "${MINGW_MOUNT_POINT}" ]; then
        for file in $(export LC_COLLATE=C; echo ${MINGW_MOUNT_POINT}/etc/profile.d/*.$1);
        do
            [ -e "${file}" ] && . "${file}";
        done;
    fi;
    }};
    function _git_tag ()
    {
        local i c="$__git_cmd_idx" f=0;
        while [ $c -lt $cword ]; do
            i="${words[c]}";
            case "$i" in
                -d | --delete | -v | --verify)
                    __gitcomp_direct "$(__git_tags "" "$cur" " ")";
                    return
                ;;
                -f)
                    f=1
                ;;
            esac;
            ((c++));
        done;
        case "$prev" in
            -m | -F)

            ;;
            -* | tag)
                if [ $f = 1 ]; then
                    __gitcomp_direct "$(__git_tags "" "$cur" " ")";
                fi
            ;;
            *)
                __git_complete_refs
            ;;
        esac;
        case "$cur" in
            --*)
                __gitcomp_builtin tag
            ;;
        esac
    };
    function _git_whatchanged ()
    {
        _git_log
    };
    function _git_worktree ()
    {
        local subcommands="add list lock move prune remove unlock";
        local subcommand subcommand_idx;
        subcommand="$(__git_find_on_cmdline --show-idx "$subcommands")";
        subcommand_idx="${subcommand% *}";
        subcommand="${subcommand#* }";
        case "$subcommand,$cur" in
            ,*)
                __gitcomp "$subcommands"
            ;;
            *,--*)
                __gitcomp_builtin worktree_$subcommand
            ;;
            add,*)
                case "$prev" in
                    -b | -B)
                        __git_complete_refs
                    ;;
                    -*)

                    ;;
                    *)
                        if [ $cword -eq $((subcommand_idx+1)) ]; then
                            :;
                        else
                            case "${words[cword-2]}" in
                                -b | -B)

                                ;;
                                *)
                                    __git_complete_refs
                                ;;
                            esac;
                        fi
                    ;;
                esac
            ;;
            lock,* | remove,* | unlock,*)
                __git_complete_worktree_paths
            ;;
            move,*)
                if [ $cword -eq $((subcommand_idx+1)) ]; then
                    __git_complete_worktree_paths;
                else
                    :;
                fi
            ;;
        esac
    };
    function profile_d ()
    {
        local file=;
        for file in $(export LC_COLLATE=C; echo /etc/profile.d/*.$1);
        do
            [ -e "${file}" ] && . "${file}";
        done;
        if [ -n "${MINGW_MOUNT_POINT}" ]; then
            for file in $(export LC_COLLATE=C; echo ${MINGW_MOUNT_POINT}/etc/profile.d/*.$1);
            do
                [ -e "${file}" ] && . "${file}";
            done;
        fi
    }
}
